## Motors Controls
# Component Selection
    1.Controller RP2040-Zero 
    2.RHINO 60-RPM 40KgCm DC Planetary Geared High Precision Encoder Servo Motor
    3.Motor Driver RMCS-2303

# Reasons Of Selection
    1.RP2040-Zero:
            The controller, RP2040-Zero, serves as the system's brain. For real-time monitoring and control, it reads encoder feedback via Modbus (UART) and transmits control directives (speed, direction, and acceleration) to the motor driver.

    2.RHINO 60-RPM 40KgCm DC Planetary Geared High Precision Encoder Servo Motor:
            Uses an integrated encoder to provide extremely precise position feedback while producing strong torque at low speeds. The planetary gearbox is perfect for robotics, automation, and positioning applications because it guarantees precise and smooth motion.    

    3.Motor Driver RMCS-2303:
            Interfaces that connect the motor to the controller.  In addition to providing the necessary power to the motor, it communicates with the RP2040 via Modbus ASCII and manages closed-loop control, encoder processing, direction control, acceleration, and protection.   

# Specifications Of the Component
    1.RP2040-Zero:
        * Dual-core ARM Cortex M0+ processor, flexible clock running up to 133 MHz
        * Built-in 264KB SRAM and 2MB Flash           
        * USB1.1 host and device support
        * Low-power sleep and dormant modes
        * Drag-and-drop programming using mass storage over USB
        * 29 GPIO pins of RP2040

    2.RHINO 60-RPM 40KgCm DC Planetary Geared High Precision Encoder Servo Motor:    
        * Operating Voltage : 12V DC
        * Motor Speed at Output Shaft(RPM) : 66RPM
        * Stall Torque(Kgcm) : 100Kgcm but not exceed greater than 75 Kgcm
        * Rated Torque(Kgcm) : 40Kgcm 
        * Gear Ratio : 1:270
        * CPR at output Shaft Of Motor : 3,60,720

    3.Motor Driver RMCS-2303:
        * Supply Voltage : 10-30V DC
        * It has short-circuit protection for the motor outputs, over-voltage and under-voltage protection and will survive accidental motor    disconnects while powered-up
        * This drive is configured using MODBUS ASCII protocol via UART

# Register Mapping
    * Refer Documents 



# ESP32 Motor Control – SmartElex 30D (ESP-IDF)

This project demonstrates basic PWM + DIR control of a **SmartElex 30D Dual Channel DC Motor Driver** using **ESP32 (ESP-IDF, pure C)**.

The first test controls **ONE motor on ONE channel**.  
After this passes, the project can be safely scaled to 4 motors.

---

## 1. System Requirements

- Ubuntu / Debian Linux
- ESP32 development board
- SmartElex 30D motor driver
- DC motor (connected to Motor-1 channel)
- USB cable
- External motor power supply (7–28 V)

---

## 2. Install ESP-IDF (One-Time Setup)

### 2.1 Install system dependencies
```bash
sudo apt update
sudo apt install -y \
  git wget flex bison gperf \
  python3 python3-pip python3-venv \
  cmake ninja-build ccache \
  libffi-dev libssl-dev dfu-util
2.2 Clone ESP-IDF
bash
Copy code
mkdir -p ~/esp
cd ~/esp
git clone --recursive https://github.com/espressif/esp-idf.git
2.3 Install ESP32 toolchain
bash
Copy code
cd ~/esp/esp-idf
./install.sh esp32
2.4 Source ESP-IDF (Required in every terminal)
bash
Copy code
source ~/esp/esp-idf/export.sh
Verify:

bash
Copy code
idf.py --version
(Optional – make permanent)

bash
Copy code
echo 'source ~/esp/esp-idf/export.sh' >> ~/.bashrc
3. Project Structure
Create the following folder structure:

css
Copy code
motor_test/
├── CMakeLists.txt
└── main/
    ├── CMakeLists.txt
    └── main.c
3.1 Root CMakeLists.txt
cmake
Copy code
cmake_minimum_required(VERSION 3.16)
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(motor_test)
3.2 main/CMakeLists.txt
cmake
Copy code
idf_component_register(SRCS "main.c"
                       INCLUDE_DIRS ".")
3.3 main.c
Paste the provided TEST-1 motor control code here (single motor PWM + DIR).

4. Generate sdkconfig
sdkconfig is auto-generated by ESP-IDF.
Do NOT create it manually.

From project root:

bash
Copy code
idf.py set-target esp32
idf.py build
This creates:

nginx
Copy code
sdkconfig
build/
5. Hardware Wiring (TEST-1)
SmartElex 30D Settings
Mode: PWM Linear Independent

SW1 = 0

SW2 = 0

SW3 = 1

SW4 = 1

Logic jumper: 3.3 V

Connect ESP32 GND to Driver GND

Wiring
SmartElex 30D	ESP32 GPIO
PWM1 (S1)	GPIO 25
DIR1	GPIO 26
GND	GND

Motor connected to Motor-1 terminals only.

⚠ Wheels OFF the ground for first test.

6. Build Firmware
bash
Copy code
idf.py build
7. Flash ESP32
7.1 Grant serial permissions (once)
bash
Copy code
sudo usermod -a -G dialout $USER
reboot
7.2 Flash
bash
Copy code
idf.py flash
(Optional monitor)

bash
Copy code
idf.py monitor
8. Expected Motor Behavior
The motor should repeat:

Forward @ ~40% speed (3 seconds)

Stop (2 seconds)

Reverse @ ~40% speed (3 seconds)

Stop (2 seconds)

If this works:

PWM wiring is correct

DIR logic is correct

Driver mode is correct

ESP32 PWM configuration is valid

9. Common Issues
Motor does not move
DIP switch mode incorrect

Logic jumper not set to 3.3 V

No common GND

Wrong PWM pin

Motor moves in only one direction
DIR pin not connected or inverted

Motor jitter / noise
Wrong mode (mixed vs independent)

PWM duty below 8%

10. Next Steps
After TEST-1 passes:

Add second motor (same driver)

Add all four motors

Add acceleration ramping

Add fault monitoring (ERR / OC pins)

Integrate higher-level control (ROS / CAN / UART)